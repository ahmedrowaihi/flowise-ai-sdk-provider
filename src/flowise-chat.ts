import type { LanguageModelV2, LanguageModelV2CallWarning } from '@ai-sdk/provider'
import { convertToFlowiseMessage } from './convert-to-flowise-message'
// import { convertFlowiseResponseToAiSdkMessage } from './convert-to-ai-sdk-message'
import { FlowiseClient } from './flowise-client'
import type { FlowisePredictionRequest } from './types'

export class FlowiseChatModel implements LanguageModelV2 {
    readonly specificationVersion = 'v2' as LanguageModelV2['specificationVersion']
    readonly defaultObjectGenerationMode = 'json'
    readonly supportsImageUrls = false
    readonly modelId = 'flowise-chatflow'

    // Added as required by LanguageModelV2
    readonly supportedUrls: Record<string, RegExp[]> = {
        'http:': [/.*/],
        'https:': [/.*/]
    }

    readonly chatflowId: string
    readonly client: FlowiseClient

    constructor(chatflowId: string, client: FlowiseClient) {
        this.chatflowId = chatflowId
        this.client = client
    }

    get provider(): string {
        return 'flowise.ai'
    }

    supportsUrl(url: URL): boolean {
        return url.protocol === 'https:' || url.protocol === 'http:'
    }

    private getArgs({ prompt }: Parameters<LanguageModelV2['doGenerate']>[0]) {
        const warnings: LanguageModelV2CallWarning[] = []

        const baseArgs: FlowisePredictionRequest = {
            question: convertToFlowiseMessage(prompt),
            chatId: undefined // Will be generated by Flowise
        }

        return {
            args: baseArgs,
            warnings
        }
    }

    async doGenerate(options: Parameters<LanguageModelV2['doGenerate']>[0]): Promise<Awaited<ReturnType<LanguageModelV2['doGenerate']>>> {
        const { args, warnings } = this.getArgs(options)

        try {
            const response = await this.client.predict(this.chatflowId, args)

            // Return content as an array of LanguageModelV2Content (text part)
            return {
                content: [{ type: 'text', text: response.text }],
                finishReason: 'stop',
                usage: {
                    inputTokens: 0, // Flowise doesn't provide token usage
                    outputTokens: 0,
                    totalTokens: 0
                },
                warnings
                // Optionally add providerMetadata, request, response if available
            }
        } catch (error) {
            throw new Error(`Flowise API error: ${error instanceof Error ? error.message : String(error)}`)
        }
    }

    async doStream(options: Parameters<LanguageModelV2['doStream']>[0]): Promise<Awaited<ReturnType<LanguageModelV2['doStream']>>> {
        const { args } = this.getArgs(options)

        try {
            const flowiseStream = await this.client.predictStream(this.chatflowId, args)

            // Transform Flowise stream to AI SDK compatible stream
            const stream = new ReadableStream({
                async start(controller) {
                    const reader = flowiseStream.getReader()

                    try {
                        // eslint-disable-next-line no-constant-condition
                        while (true) {
                            const { done, value } = await reader.read()
                            if (done) break

                            // Only pass through text-delta chunks that match AI SDK format
                            if (value && typeof value === 'object' && value.type === 'text-delta' && value.textDelta) {
                                controller.enqueue({
                                    type: 'text-delta',
                                    id: '', // Provide an id if required by the SDK, else leave blank
                                    delta: value.textDelta
                                })
                            }
                        }
                        controller.close()
                    } catch (error) {
                        controller.error(error)
                    } finally {
                        reader.releaseLock()
                    }
                }
            })

            return {
                stream
                // Optionally add request, response if available
            }
        } catch (error) {
            throw new Error(`Flowise streaming error: ${error instanceof Error ? error.message : String(error)}`)
        }
    }
}
